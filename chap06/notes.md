# 第六章：浮点数

## 1. 浮点数类型

### 1.1 float32 和 float64

| 类型 | 说明 | 字节数 | 有效数字 | 精度 |
|------|------|--------|---------|------|
| `float32` | 单精度浮点数 | 4 | 约 6-7 位 | 较低 |
| `float64` | 双精度浮点数 | 8 | 约 15-16 位 | 较高 |

**注意**：
- Go 里**没有 `double` 关键字**
- `float64` 就是双精度浮点数，和其他语言的 `double` 等价
- Go **默认推断为 `float64`**，因为精度更高

### 1.2 类型推断

```go
// 自动推断为 float64
var pi = 3.14        // float64
pi2 := 3.14         // float64

// 显式声明类型
var pi3 float32 = 3.14  // float32
var pi4 float64 = 3.14  // float64
```

**规则**：
- 带小数点的数字默认推断为 `float64`
- 如果想用 `float32`，需要显式声明或使用 `3.14f`（但 Go 不支持 f 后缀）

### 1.3 零值问题

```go
var num int        // 零值是 0
var pi float64     // 零值是 0.0

var num2 = 0       // 推断为 int
var num3 = 0.0     // 推断为 float64
```

**要点**：
- 整数类型的零值是 `0`
- 浮点数类型的零值是 `0.0`
- 赋值 `0` 会被推断为 `int`
- 赋值 `0.0` 会被推断为 `float64`

## 2. 打印浮点数

### 2.1 格式占位符

| 格式 | 说明 | 示例 |
|------|------|------|
| `%f` | 默认格式 | `3.140000` |
| `%.3f` | 保留 3 位小数 | `3.140` |
| `%4.2f` | 总宽度 4，保留 2 位小数 | `3.14` |
| `%v` | 通用占位符，自动识别类型 | `3.14` |

### 2.2 示例

```go
value := 1.0 / 3

fmt.Printf("%f\n", value)        // 默认格式
fmt.Printf("%.3f\n", value)     // 保留 3 位：0.333
fmt.Printf("%4.2f\n", value)     // 宽度 4，保留 2 位：0.33
fmt.Printf("%v\n", value)        // 通用格式
fmt.Println(value)               // 完整精度
```

### 2.3 避免显示误差

**方法**：使用 `fmt.Printf` 指定精确的小数位数

```go
pinkBlack := 0.1 + 0.2

fmt.Printf("%.1f\n", pinkBlack)  // 显示 0.3（四舍五入）
fmt.Printf("%.2f\n", pinkBlack)   // 显示 0.30
```

**注意**：
- 这只是**显示层面的处理**
- 变量本身存储的还是 `0.30000000000000004`
- 如果后续还要计算，误差依然存在

## 3. 浮点数精度问题

### 3.1 精度损失的原因

1. **二进制表示限制**：计算机用二进制表示浮点数
2. **无限循环**：十进制小数（如 `0.1`、`1/3`）转二进制可能是无限循环
3. **有限存储**：计算机只能保留有限位（`float64` 约 53 位有效数字）
4. **舍入误差**：导致精度损失

### 3.2 典型例子

#### 例子1：1/3 的精度损失
```go
oneThird := 1.0 / 3
// 理论上：1/3 + 1/3 + 1/3 = 1
// 实际上：sum = 0.9999999999999999 ≠ 1.0
sum := oneThird + oneThird + oneThird
fmt.Println(sum == 1.0)  // false
```

#### 例子2：0.1 + 0.2 的舍入误差
```go
pinkBlack := 0.1
pinkBlack += 0.2
// 结果：0.30000000000000004 ≠ 0.3
fmt.Println(pinkBlack == 0.3)  // false
```

### 3.3 计算技巧：先乘后除

**原则**：**乘法放在除法前面执行，会得到更精确的结果**

```go
a, b, c := 123456.0, 789.0, 10000.0

// ✅ 先乘后除：更精确
result1 := (a * b) / c

// ❌ 先除后乘：可能精度损失
result2 := (a / c) * b
```

**原因**：
- 先除可能得到很小的小数，再乘时精度损失
- 先乘得到较大的数，再除能保留更多有效数字

## 4. 浮点数比较

### 4.1 错误的比较方式

```go
// ❌ 错误：直接用 == 比较浮点数
pinkBlack := 0.1 + 0.2
fmt.Println(pinkBlack == 0.3)  // false（因为精度误差）
```

### 4.2 正确的比较方式

**方法**：判断两个数的差值是否小于一个很小的数（epsilon）

```go
import "math"

pinkBlack := 0.1 + 0.2
epsilon := 0.0001  // 或 1e-9

// ✅ 正确：使用 math.Abs 判断差值
isEqual := math.Abs(pinkBlack - 0.3) < epsilon
fmt.Println(isEqual)  // true
```

### 4.3 epsilon 的选择

| 场景 | epsilon 值 | 说明 |
|------|-----------|------|
| 普通业务场景 | `1e-9` (0.000000001) | 常用 |
| 高精度科学计算 | `1e-15` (0.000000000000001) | 更严格 |
| 一般计算 | `0.0001` | 更宽松 |

**原则**：
- **太小**：可能把真正相等的数误判为不等
- **太大**：可能把不相等的数误判为相等
- 要根据实际精度需求选择

### 4.4 比较函数示例

```go
func floatEqual(a, b, epsilon float64) bool {
    return math.Abs(a - b) < epsilon
}

// 使用
isEqual := floatEqual(0.1+0.2, 0.3, 1e-9)
```

## 5. 总结

### 浮点数类型
- `float32`：单精度，4 字节，约 6-7 位有效数字
- `float64`：双精度，8 字节，约 15-16 位有效数字（默认）
- Go 没有 `double`，`float64` 就是双精度

### 类型推断
- 带小数点的数字默认推断为 `float64`
- `0` 推断为 `int`，`0.0` 推断为 `float64`

### 打印格式
- `%.nf`：保留 n 位小数
- `%m.nf`：总宽度 m，保留 n 位小数
- 指定宽度可以避免显示误差

### 精度问题
- 原因：二进制表示限制，无限循环小数只能保留有限位
- 典型例子：`0.1 + 0.2 = 0.30000000000000004`
- 计算技巧：先乘后除更精确

### 浮点数比较
- **不能用 `==`**：因为精度误差
- **要用 `math.Abs(a - b) < epsilon`**：判断差值
- epsilon 选择：普通场景用 `1e-9`

### 关键点
1. Go 的浮点数设计简单、严谨
2. 默认 `float64` 精度高，适合大多数场景
3. 注意精度损失，比较时用差值判断
4. 打印时指定宽度，避免显示误差


